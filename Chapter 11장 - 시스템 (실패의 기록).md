11장은 코드차원이 아니라, 시스템 전체적인 차원에서 중요한 '**관심사 분리**' 를 다룬다.

관심사 분리란 **객체생성과 그 사용을 분리하는 것**이고, 이를 실행하기 위한 여러 방식들을 다루고 있다.

문제는 그 방식들이 내 수준에서 이해하기 어렵다는 점이다. 11-1 예제부터 도저히 지금 내 실력으로 이해가 되지 않았다. 

그 이전의 흐름까지만 정리하고, 복습의 나에게 이해를 넘기기로 했다. 

단순 정리만 할까 고민해봤는데, 그러면 내 스스로 타협하고 다시는 안볼 것 같아서 이해한 만큼만 정리하고 

미완성으로 남기기로 했다. **반드시 완전히 정리할 것....**

#### **도시를 세운다면?**

-   도시가 잘 돌아가는 이유는 추상화와 모듈화 때문이다.   
    소프트웨어 역시 이와 같다.

#### **시스템 제작과 시스템 사용을 분리하라**

-   관심사를 분리하라 

```java
public Service getService() {
    if (service == null) {
        service = new MyServiceImpl(...)
    }
    return service;
}
```

1.  MyServiceImpl 객체와 그 생성자 인수에 명시적으로 의존한다.
2.  단위테스트에서 getService 메서드 호출하기전에 테스트 전용 객체를 Service 필드에 할당해야한다.
3.  service 가 null 인경우와 아닌경우 모두 테스트해야 한다. (단일책임 원칙을 위반한다)
4.  MyServiceImpl 객체가 모든 상황에 적합한 객체인지 알 수 없다. ( 단일 객체가 모든 맥락에 맞을 수 없다)

#### **\-  Main 분리**

-   생성과 관련한 코드는 모두 main 모듈로 옮기고, 나머지 시스템은 객체가 모두 생성되었고, 의존성이 연결되었다고 가정한다.

#### **\- 팩토리**

-   때때로 애플리케이션이 객체생성 시점을 결정해야 할때가 있다. 
-   추상 팩토리 패턴 (Abstract Factory) 패턴을 사용한다.

#### **\- 의존성 주입** 

-   객체생성을 다른 메커니즘에 넘기고, 제어역전을 발생시키는 것
-   대표적으로 스프링프레임워크가 있다.
